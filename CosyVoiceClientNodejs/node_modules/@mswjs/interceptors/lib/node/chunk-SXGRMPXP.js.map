{"version":3,"sources":["../../src/interceptors/ClientRequest/index.ts","../../src/interceptors/ClientRequest/NodeClientRequest.ts","../../src/interceptors/ClientRequest/utils/normalizeClientRequestEndArgs.ts","../../src/interceptors/ClientRequest/utils/normalizeClientRequestWriteArgs.ts","../../src/interceptors/ClientRequest/utils/cloneIncomingMessage.ts","../../src/interceptors/ClientRequest/utils/createResponse.ts","../../src/interceptors/ClientRequest/utils/createRequest.ts","../../src/utils/getValueBySymbol.ts","../../src/utils/isObject.ts","../../src/utils/getRawFetchHeaders.ts","../../src/utils/isNodeLikeError.ts","../../src/interceptors/ClientRequest/utils/normalizeClientRequestArgs.ts","../../src/utils/getRequestOptionsByUrl.ts","../../src/utils/getUrlByRequestOptions.ts","../../src/utils/cloneObject.ts","../../src/interceptors/ClientRequest/http.get.ts","../../src/interceptors/ClientRequest/http.request.ts"],"names":["IncomingMessage","Logger","logger","symbol","chunk","encoding","url","options","request"],"mappings":"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","sourcesContent":["import http from 'http'\nimport https from 'https'\nimport type { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { get } from './http.get'\nimport { request } from './http.request'\nimport { NodeClientOptions, Protocol } from './NodeClientRequest'\n\nexport type ClientRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport type ClientRequestModules = Map<Protocol, typeof http | typeof https>\n\n/**\n * Intercept requests made via the `ClientRequest` class.\n * Such requests include `http.get`, `https.request`, etc.\n */\nexport class ClientRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('http')\n  private modules: ClientRequestModules\n\n  constructor() {\n    super(ClientRequestInterceptor.interceptorSymbol)\n\n    this.modules = new Map()\n    this.modules.set('http', http)\n    this.modules.set('https', https)\n  }\n\n  protected setup(): void {\n    const logger = this.logger.extend('setup')\n\n    for (const [protocol, requestModule] of this.modules) {\n      const { request: pureRequest, get: pureGet } = requestModule\n\n      this.subscriptions.push(() => {\n        requestModule.request = pureRequest\n        requestModule.get = pureGet\n\n        logger.info('native \"%s\" module restored!', protocol)\n      })\n\n      const options: NodeClientOptions = {\n        emitter: this.emitter,\n        logger: this.logger,\n      }\n\n      // @ts-ignore\n      requestModule.request =\n        // Force a line break.\n        request(protocol, options)\n\n      // @ts-ignore\n      requestModule.get =\n        // Force a line break.\n        get(protocol, options)\n\n      logger.info('native \"%s\" module patched!', protocol)\n    }\n  }\n}\n","import { ClientRequest, IncomingMessage, STATUS_CODES } from 'node:http'\nimport type { Logger } from '@open-draft/logger'\nimport { until } from '@open-draft/until'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { ClientRequestEmitter } from '.'\nimport {\n  ClientRequestEndCallback,\n  ClientRequestEndChunk,\n  normalizeClientRequestEndArgs,\n} from './utils/normalizeClientRequestEndArgs'\nimport { NormalizedClientRequestArgs } from './utils/normalizeClientRequestArgs'\nimport {\n  ClientRequestWriteArgs,\n  normalizeClientRequestWriteArgs,\n} from './utils/normalizeClientRequestWriteArgs'\nimport { cloneIncomingMessage } from './utils/cloneIncomingMessage'\nimport { createResponse } from './utils/createResponse'\nimport { createRequest } from './utils/createRequest'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { getRawFetchHeaders } from '../../utils/getRawFetchHeaders'\nimport { isNodeLikeError } from '../../utils/isNodeLikeError'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n} from '../../utils/responseUtils'\n\nexport type Protocol = 'http' | 'https'\n\nenum HttpClientInternalState {\n  // Have the concept of an idle request because different\n  // request methods can kick off request sending\n  // (e.g. \".end()\" or \".flushHeaders()\").\n  Idle,\n  Sending,\n  Sent,\n  MockLookupStart,\n  MockLookupEnd,\n  ResponseReceived,\n}\n\nexport interface NodeClientOptions {\n  emitter: ClientRequestEmitter\n  logger: Logger\n}\n\nexport class NodeClientRequest extends ClientRequest {\n  /**\n   * The list of internal Node.js errors to suppress while\n   * using the \"mock\" response source.\n   */\n  static suppressErrorCodes = [\n    'ENOTFOUND',\n    'ECONNREFUSED',\n    'ECONNRESET',\n    'EAI_AGAIN',\n    'ENETUNREACH',\n    'EHOSTUNREACH',\n  ]\n\n  /**\n   * Internal state of the request.\n   */\n  private state: HttpClientInternalState\n  private responseType?: 'mock' | 'passthrough'\n  private response: IncomingMessage\n  private emitter: ClientRequestEmitter\n  private logger: Logger\n  private chunks: Array<{\n    chunk?: string | Buffer\n    encoding?: BufferEncoding\n  }> = []\n  private capturedError?: NodeJS.ErrnoException\n\n  public url: URL\n  public requestBuffer: Buffer | null\n\n  constructor(\n    [url, requestOptions, callback]: NormalizedClientRequestArgs,\n    options: NodeClientOptions\n  ) {\n    super(requestOptions, callback)\n\n    this.logger = options.logger.extend(\n      `request ${requestOptions.method} ${url.href}`\n    )\n\n    this.logger.info('constructing ClientRequest using options:', {\n      url,\n      requestOptions,\n      callback,\n    })\n\n    this.state = HttpClientInternalState.Idle\n    this.url = url\n    this.emitter = options.emitter\n\n    // Set request buffer to null by default so that GET/HEAD requests\n    // without a body wouldn't suddenly get one.\n    this.requestBuffer = null\n\n    // Construct a mocked response message.\n    this.response = new IncomingMessage(this.socket!)\n  }\n\n  private writeRequestBodyChunk(\n    chunk: string | Buffer | null,\n    encoding?: BufferEncoding\n  ): void {\n    if (chunk == null) {\n      return\n    }\n\n    if (this.requestBuffer == null) {\n      this.requestBuffer = Buffer.from([])\n    }\n\n    const resolvedChunk = Buffer.isBuffer(chunk)\n      ? chunk\n      : Buffer.from(chunk, encoding)\n\n    this.requestBuffer = Buffer.concat([this.requestBuffer, resolvedChunk])\n  }\n\n  write(...args: ClientRequestWriteArgs): boolean {\n    const [chunk, encoding, callback] = normalizeClientRequestWriteArgs(args)\n    this.logger.info('write:', { chunk, encoding, callback })\n    this.chunks.push({ chunk, encoding })\n\n    // Write each request body chunk to the internal buffer.\n    this.writeRequestBodyChunk(chunk, encoding)\n\n    this.logger.info(\n      'chunk successfully stored!',\n      this.requestBuffer?.byteLength\n    )\n\n    /**\n     * Prevent invoking the callback if the written chunk is empty.\n     * @see https://nodejs.org/api/http.html#requestwritechunk-encoding-callback\n     */\n    if (!chunk || chunk.length === 0) {\n      this.logger.info('written chunk is empty, skipping callback...')\n    } else {\n      callback?.()\n    }\n\n    // Do not write the request body chunks to prevent\n    // the Socket from sending data to a potentially existing\n    // server when there is a mocked response defined.\n    return true\n  }\n\n  end(...args: any): this {\n    this.logger.info('end', args)\n\n    const requestId = createRequestId()\n\n    const [chunk, encoding, callback] = normalizeClientRequestEndArgs(...args)\n    this.logger.info('normalized arguments:', { chunk, encoding, callback })\n\n    // Write the last request body chunk passed to the \"end()\" method.\n    this.writeRequestBodyChunk(chunk, encoding || undefined)\n\n    /**\n     * @note Mark the request as sent immediately when invoking \".end()\".\n     * In Node.js, calling \".end()\" will flush the remaining request body\n     * and mark the request as \"finished\" immediately (\"end\" is synchronous)\n     * but we delegate that property update to:\n     *\n     * - respondWith(), in the case of mocked responses;\n     * - super.end(), in the case of bypassed responses.\n     *\n     * For that reason, we have to keep an internal flag for a finished request.\n     */\n    this.state = HttpClientInternalState.Sent\n\n    const capturedRequest = createRequest(this)\n    const { interactiveRequest, requestController } =\n      toInteractiveRequest(capturedRequest)\n\n    /**\n     * @todo Remove this modification of the original request\n     * and expose the controller alongside it in the \"request\"\n     * listener argument.\n     */\n    Object.defineProperty(capturedRequest, 'respondWith', {\n      value: requestController.respondWith.bind(requestController),\n    })\n\n    // Prevent handling this request if it has already been handled\n    // in another (parent) interceptor (like XMLHttpRequest -> ClientRequest).\n    // That means some interceptor up the chain has concluded that\n    // this request must be performed as-is.\n    if (this.hasHeader(INTERNAL_REQUEST_ID_HEADER_NAME)) {\n      this.removeHeader(INTERNAL_REQUEST_ID_HEADER_NAME)\n      return this.passthrough(chunk, encoding, callback)\n    }\n\n    // Add the last \"request\" listener that always resolves\n    // the pending response Promise. This way if the consumer\n    // hasn't handled the request themselves, we will prevent\n    // the response Promise from pending indefinitely.\n    this.emitter.once('request', ({ requestId: pendingRequestId }) => {\n      /**\n       * @note Ignore request events emitted by irrelevant\n       * requests. This happens when response patching.\n       */\n      if (pendingRequestId !== requestId) {\n        return\n      }\n\n      if (requestController.responsePromise.state === 'pending') {\n        this.logger.info(\n          'request has not been handled in listeners, executing fail-safe listener...'\n        )\n\n        requestController.responsePromise.resolve(undefined)\n      }\n    })\n\n    // Execute the resolver Promise like a side-effect.\n    // Node.js 16 forces \"ClientRequest.end\" to be synchronous and return \"this\".\n    until<unknown, Response | undefined>(async () => {\n      // Notify the interceptor about the request.\n      // This will call any \"request\" listeners the users have.\n      this.logger.info(\n        'emitting the \"request\" event for %d listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      this.state = HttpClientInternalState.MockLookupStart\n\n      await emitAsync(this.emitter, 'request', {\n        request: interactiveRequest,\n        requestId,\n      })\n\n      this.logger.info('all \"request\" listeners done!')\n\n      const mockedResponse = await requestController.responsePromise\n      this.logger.info('event.respondWith called with:', mockedResponse)\n\n      return mockedResponse\n    }).then((resolverResult) => {\n      this.logger.info('the listeners promise awaited!')\n\n      this.state = HttpClientInternalState.MockLookupEnd\n\n      /**\n       * @fixme We are in the \"end()\" method that still executes in parallel\n       * to our mocking logic here. This can be solved by migrating to the\n       * Proxy-based approach and deferring the passthrough \"end()\" properly.\n       * @see https://github.com/mswjs/interceptors/issues/346\n       */\n      if (!this.headersSent) {\n        // Forward any request headers that the \"request\" listener\n        // may have modified before proceeding with this request.\n        for (const [headerName, headerValue] of capturedRequest.headers) {\n          this.setHeader(headerName, headerValue)\n        }\n      }\n\n      if (resolverResult.error) {\n        this.logger.info(\n          'unhandled resolver exception, coercing to an error response...',\n          resolverResult.error\n        )\n\n        // Handle thrown Response instances.\n        if (resolverResult.error instanceof Response) {\n          // Treat thrown Response.error() as a request error.\n          if (isResponseError(resolverResult.error)) {\n            this.logger.info(\n              'received network error response, erroring request...'\n            )\n\n            this.errorWith(new TypeError('Network error'))\n          } else {\n            // Handle a thrown Response as a mocked response.\n            this.respondWith(resolverResult.error)\n          }\n\n          return\n        }\n\n        // Allow throwing Node.js-like errors, like connection rejection errors.\n        // Treat them as request errors.\n        if (isNodeLikeError(resolverResult.error)) {\n          this.errorWith(resolverResult.error)\n          return this\n        }\n\n        until(async () => {\n          if (this.emitter.listenerCount('unhandledException') > 0) {\n            // Emit the \"unhandledException\" event to allow the client\n            // to opt-out from the default handling of exceptions\n            // as 500 error responses.\n            await emitAsync(this.emitter, 'unhandledException', {\n              error: resolverResult.error,\n              request: capturedRequest,\n              requestId,\n              controller: {\n                respondWith: this.respondWith.bind(this),\n                errorWith: this.errorWith.bind(this),\n              },\n            })\n\n            // If after the \"unhandledException\" listeners are done,\n            // the request is either not writable (was mocked) or\n            // destroyed (has errored), do nothing.\n            if (this.writableEnded || this.destroyed) {\n              return\n            }\n          }\n\n          // Unhandled exceptions in the request listeners are\n          // synonymous to unhandled exceptions on the server.\n          // Those are represented as 500 error responses.\n          this.respondWith(createServerErrorResponse(resolverResult.error))\n        })\n\n        return this\n      }\n\n      const mockedResponse = resolverResult.data\n\n      if (mockedResponse) {\n        this.logger.info(\n          'received mocked response:',\n          mockedResponse.status,\n          mockedResponse.statusText\n        )\n\n        /**\n         * @note Ignore this request being destroyed by TLS in Node.js\n         * due to connection errors.\n         */\n        this.destroyed = false\n\n        // Handle mocked \"Response.error\" network error responses.\n        if (isResponseError(mockedResponse)) {\n          this.logger.info(\n            'received network error response, erroring request...'\n          )\n\n          /**\n           * There is no standardized error format for network errors\n           * in Node.js. Instead, emit a generic TypeError.\n           */\n          this.errorWith(new TypeError('Network error'))\n\n          return this\n        }\n\n        const responseClone = mockedResponse.clone()\n\n        this.respondWith(mockedResponse)\n        this.logger.info(\n          mockedResponse.status,\n          mockedResponse.statusText,\n          '(MOCKED)'\n        )\n\n        callback?.()\n\n        this.logger.info('emitting the custom \"response\" event...')\n        this.emitter.emit('response', {\n          response: responseClone,\n          isMockedResponse: true,\n          request: capturedRequest,\n          requestId,\n        })\n\n        this.logger.info('request (mock) is completed')\n\n        return this\n      }\n\n      this.logger.info('no mocked response received!')\n\n      this.once('response-internal', (message: IncomingMessage) => {\n        this.logger.info(message.statusCode, message.statusMessage)\n        this.logger.info('original response headers:', message.headers)\n\n        this.logger.info('emitting the custom \"response\" event...')\n        this.emitter.emit('response', {\n          response: createResponse(message),\n          isMockedResponse: false,\n          request: capturedRequest,\n          requestId,\n        })\n      })\n\n      return this.passthrough(chunk, encoding, callback)\n    })\n\n    return this\n  }\n\n  emit(event: string, ...data: any[]) {\n    this.logger.info('emit: %s', event)\n\n    if (event === 'response') {\n      this.logger.info('found \"response\" event, cloning the response...')\n\n      try {\n        /**\n         * Clone the response object when emitting the \"response\" event.\n         * This prevents the response body stream from locking\n         * and allows reading it twice:\n         * 1. Internal \"response\" event from the observer.\n         * 2. Any external response body listeners.\n         * @see https://github.com/mswjs/interceptors/issues/161\n         */\n        const response = data[0] as IncomingMessage\n        const firstClone = cloneIncomingMessage(response)\n        const secondClone = cloneIncomingMessage(response)\n\n        this.emit('response-internal', secondClone)\n\n        this.logger.info(\n          'response successfully cloned, emitting \"response\" event...'\n        )\n        return super.emit(event, firstClone, ...data.slice(1))\n      } catch (error) {\n        this.logger.info('error when cloning response:', error)\n        return super.emit(event, ...data)\n      }\n    }\n\n    if (event === 'error') {\n      const error = data[0] as NodeJS.ErrnoException\n      const errorCode = error.code || ''\n\n      this.logger.info('error:\\n', error)\n\n      // Suppress only specific Node.js connection errors.\n      if (NodeClientRequest.suppressErrorCodes.includes(errorCode)) {\n        // Until we aren't sure whether the request will be\n        // passthrough, capture the first emitted connection\n        // error in case we have to replay it for this request.\n        if (this.state < HttpClientInternalState.MockLookupEnd) {\n          if (!this.capturedError) {\n            this.capturedError = error\n            this.logger.info('captured the first error:', this.capturedError)\n          }\n          return false\n        }\n\n        // Ignore any connection errors once we know the request\n        // has been resolved with a mocked response. Don't capture\n        // them as they won't ever be replayed.\n        if (\n          this.state === HttpClientInternalState.ResponseReceived &&\n          this.responseType === 'mock'\n        ) {\n          return false\n        }\n      }\n    }\n\n    return super.emit(event, ...data)\n  }\n\n  /**\n   * Performs the intercepted request as-is.\n   * Replays the captured request body chunks,\n   * still emits the internal events, and wraps\n   * up the request with `super.end()`.\n   */\n  private passthrough(\n    chunk: ClientRequestEndChunk | null,\n    encoding?: BufferEncoding | null,\n    callback?: ClientRequestEndCallback | null\n  ): this {\n    this.state = HttpClientInternalState.ResponseReceived\n    this.responseType = 'passthrough'\n\n    // Propagate previously captured errors.\n    // For example, a ECONNREFUSED error when connecting to a non-existing host.\n    if (this.capturedError) {\n      this.emit('error', this.capturedError)\n      return this\n    }\n\n    this.logger.info('writing request chunks...', this.chunks)\n\n    // Write the request body chunks in the order of \".write()\" calls.\n    // Note that no request body has been written prior to this point\n    // in order to prevent the Socket to communicate with a potentially\n    // existing server.\n    for (const { chunk, encoding } of this.chunks) {\n      if (encoding) {\n        super.write(chunk, encoding)\n      } else {\n        super.write(chunk)\n      }\n    }\n\n    this.once('error', (error) => {\n      this.logger.info('original request error:', error)\n    })\n\n    this.once('abort', () => {\n      this.logger.info('original request aborted!')\n    })\n\n    this.once('response-internal', (message: IncomingMessage) => {\n      this.logger.info(message.statusCode, message.statusMessage)\n      this.logger.info('original response headers:', message.headers)\n    })\n\n    this.logger.info('performing original request...')\n\n    // This call signature is way too dynamic.\n    return super.end(...[chunk, encoding as any, callback].filter(Boolean))\n  }\n\n  /**\n   * Responds to this request instance using a mocked response.\n   */\n  private respondWith(mockedResponse: Response): void {\n    this.logger.info('responding with a mocked response...', mockedResponse)\n\n    this.state = HttpClientInternalState.ResponseReceived\n    this.responseType = 'mock'\n\n    /**\n     * Mark the request as finished right before streaming back the response.\n     * This is not entirely conventional but this will allow the consumer to\n     * modify the outoging request in the interceptor.\n     *\n     * The request is finished when its headers and bodies have been sent.\n     * @see https://nodejs.org/api/http.html#event-finish\n     */\n    Object.defineProperties(this, {\n      writableFinished: { value: true },\n      writableEnded: { value: true },\n    })\n    this.emit('finish')\n\n    const { status, statusText, headers, body } = mockedResponse\n    this.response.statusCode = status\n    this.response.statusMessage = statusText || STATUS_CODES[status]\n\n    // Try extracting the raw headers from the headers instance.\n    // If not possible, fallback to the headers instance as-is.\n    const rawHeaders = getRawFetchHeaders(headers) || headers\n\n    if (rawHeaders) {\n      this.response.headers = {}\n\n      rawHeaders.forEach((headerValue, headerName) => {\n        /**\n         * @note Make sure that multi-value headers are appended correctly.\n         */\n        this.response.rawHeaders.push(headerName, headerValue)\n\n        const insensitiveHeaderName = headerName.toLowerCase()\n        const prevHeaders = this.response.headers[insensitiveHeaderName]\n        this.response.headers[insensitiveHeaderName] = prevHeaders\n          ? Array.prototype.concat([], prevHeaders, headerValue)\n          : headerValue\n      })\n    }\n    this.logger.info('mocked response headers ready:', headers)\n\n    /**\n     * Set the internal \"res\" property to the mocked \"OutgoingMessage\"\n     * to make the \"ClientRequest\" instance think there's data received\n     * from the socket.\n     * @see https://github.com/nodejs/node/blob/9c405f2591f5833d0247ed0fafdcd68c5b14ce7a/lib/_http_client.js#L501\n     *\n     * Set the response immediately so the interceptor could stream data\n     * chunks to the request client as they come in.\n     */\n    // @ts-ignore\n    this.res = this.response\n    this.emit('response', this.response)\n\n    const isResponseStreamFinished = new DeferredPromise<void>()\n\n    const finishResponseStream = () => {\n      this.logger.info('finished response stream!')\n\n      // Push \"null\" to indicate that the response body is complete\n      // and shouldn't be written to anymore.\n      this.response.push(null)\n      this.response.complete = true\n\n      isResponseStreamFinished.resolve()\n    }\n\n    if (body) {\n      const bodyReader = body.getReader()\n      const readNextChunk = async (): Promise<void> => {\n        const { done, value } = await bodyReader.read()\n\n        if (done) {\n          finishResponseStream()\n          return\n        }\n\n        this.response.emit('data', value)\n\n        return readNextChunk()\n      }\n\n      readNextChunk()\n    } else {\n      finishResponseStream()\n    }\n\n    isResponseStreamFinished.then(() => {\n      this.logger.info('finalizing response...')\n      this.response.emit('end')\n      this.terminate()\n\n      this.logger.info('request complete!')\n    })\n  }\n\n  private errorWith(error: Error): void {\n    this.destroyed = true\n    this.emit('error', error)\n    this.terminate()\n  }\n\n  /**\n   * Terminates a pending request.\n   */\n  private terminate(): void {\n    /**\n     * @note Some request clients (e.g. Octokit) create a ClientRequest\n     * in a way that it has no Agent set. Now, whether that's correct is\n     * debatable, but we should still handle this case gracefully.\n     * @see https://github.com/mswjs/interceptors/issues/304\n     */\n    // @ts-ignore\n    this.agent?.destroy()\n  }\n}\n","import { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('utils getUrlByRequestOptions')\n\nexport type ClientRequestEndChunk = string | Buffer\nexport type ClientRequestEndCallback = () => void\n\ntype HttpRequestEndArgs =\n  | []\n  | [ClientRequestEndCallback]\n  | [ClientRequestEndChunk, ClientRequestEndCallback?]\n  | [ClientRequestEndChunk, BufferEncoding, ClientRequestEndCallback?]\n\ntype NormalizedHttpRequestEndParams = [\n  ClientRequestEndChunk | null,\n  BufferEncoding | null,\n  ClientRequestEndCallback | null\n]\n\n/**\n * Normalizes a list of arguments given to the `ClientRequest.end()`\n * method to always include `chunk`, `encoding`, and `callback`.\n */\nexport function normalizeClientRequestEndArgs(\n  ...args: HttpRequestEndArgs\n): NormalizedHttpRequestEndParams {\n  logger.info('arguments', args)\n  const normalizedArgs = new Array(3)\n    .fill(null)\n    .map((value, index) => args[index] || value)\n\n  normalizedArgs.sort((a, b) => {\n    // If first element is a function, move it rightwards.\n    if (typeof a === 'function') {\n      return 1\n    }\n\n    // If second element is a function, move the first leftwards.\n    if (typeof b === 'function') {\n      return -1\n    }\n\n    // If both elements are strings, preserve their original index.\n    if (typeof a === 'string' && typeof b === 'string') {\n      return normalizedArgs.indexOf(a) - normalizedArgs.indexOf(b)\n    }\n\n    return 0\n  })\n\n  logger.info('normalized args', normalizedArgs)\n  return normalizedArgs as NormalizedHttpRequestEndParams\n}\n","import { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('http normalizeWriteArgs')\n\nexport type ClientRequestWriteCallback = (error?: Error | null) => void\nexport type ClientRequestWriteArgs = [\n  chunk: string | Buffer,\n  encoding?: BufferEncoding | ClientRequestWriteCallback,\n  callback?: ClientRequestWriteCallback\n]\n\nexport type NormalizedClientRequestWriteArgs = [\n  chunk: string | Buffer,\n  encoding?: BufferEncoding,\n  callback?: ClientRequestWriteCallback\n]\n\nexport function normalizeClientRequestWriteArgs(\n  args: ClientRequestWriteArgs\n): NormalizedClientRequestWriteArgs {\n  logger.info('normalizing ClientRequest.write arguments...', args)\n\n  const chunk = args[0]\n  const encoding =\n    typeof args[1] === 'string' ? (args[1] as BufferEncoding) : undefined\n  const callback = typeof args[1] === 'function' ? args[1] : args[2]\n\n  const writeArgs: NormalizedClientRequestWriteArgs = [\n    chunk,\n    encoding,\n    callback,\n  ]\n  logger.info(\n    'successfully normalized ClientRequest.write arguments:',\n    writeArgs\n  )\n\n  return writeArgs\n}\n","import { IncomingMessage } from 'http'\nimport { PassThrough } from 'stream'\n\nexport const IS_CLONE = Symbol('isClone')\n\nexport interface ClonedIncomingMessage extends IncomingMessage {\n  [IS_CLONE]: boolean\n}\n\n/**\n * Clones a given `http.IncomingMessage` instance.\n */\nexport function cloneIncomingMessage(\n  message: IncomingMessage\n): ClonedIncomingMessage {\n  const clone = message.pipe(new PassThrough())\n\n  // Inherit all direct \"IncomingMessage\" properties.\n  inheritProperties(message, clone)\n\n  // Deeply inherit the message prototypes (Readable, Stream, EventEmitter, etc.).\n  const clonedPrototype = Object.create(IncomingMessage.prototype)\n  getPrototypes(clone).forEach((prototype) => {\n    inheritProperties(prototype, clonedPrototype)\n  })\n  Object.setPrototypeOf(clone, clonedPrototype)\n\n  Object.defineProperty(clone, IS_CLONE, {\n    enumerable: true,\n    value: true,\n  })\n\n  return clone as unknown as ClonedIncomingMessage\n}\n\n/**\n * Returns a list of all prototypes the given object extends.\n */\nfunction getPrototypes(source: object): object[] {\n  const prototypes: object[] = []\n  let current = source\n\n  while ((current = Object.getPrototypeOf(current))) {\n    prototypes.push(current)\n  }\n\n  return prototypes\n}\n\n/**\n * Inherits a given target object properties and symbols\n * onto the given source object.\n * @param source Object which should acquire properties.\n * @param target Object to inherit the properties from.\n */\nfunction inheritProperties(source: object, target: object): void {\n  const properties = [\n    ...Object.getOwnPropertyNames(source),\n    ...Object.getOwnPropertySymbols(source),\n  ]\n\n  for (const property of properties) {\n    if (target.hasOwnProperty(property)) {\n      continue\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(source, property)\n    if (!descriptor) {\n      continue\n    }\n\n    Object.defineProperty(target, property, descriptor)\n  }\n}\n","import type { IncomingHttpHeaders, IncomingMessage } from 'http'\nimport { isResponseWithoutBody } from '../../../utils/responseUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `http.IncomingMessage` instance.\n */\nexport function createResponse(message: IncomingMessage): Response {\n  const responseBodyOrNull = isResponseWithoutBody(message.statusCode || 200)\n    ? null\n    : new ReadableStream({\n        start(controller) {\n          message.on('data', (chunk) => controller.enqueue(chunk))\n          message.on('end', () => controller.close())\n\n          /**\n           * @todo Should also listen to the \"error\" on the message\n           * and forward it to the controller. Otherwise the stream\n           * will pend indefinitely.\n           */\n        },\n      })\n\n  return new Response(responseBodyOrNull, {\n    status: message.statusCode,\n    statusText: message.statusMessage,\n    headers: createHeadersFromIncomingHttpHeaders(message.headers),\n  })\n}\n\nfunction createHeadersFromIncomingHttpHeaders(\n  httpHeaders: IncomingHttpHeaders\n): Headers {\n  const headers = new Headers()\n\n  for (const headerName in httpHeaders) {\n    const headerValues = httpHeaders[headerName]\n\n    if (typeof headerValues === 'undefined') {\n      continue\n    }\n\n    if (Array.isArray(headerValues)) {\n      headerValues.forEach((headerValue) => {\n        headers.append(headerName, headerValue)\n      })\n\n      continue\n    }\n\n    headers.set(headerName, headerValues)\n  }\n\n  return headers\n}\n","import type { NodeClientRequest } from '../NodeClientRequest'\n\n/**\n * Creates a Fetch API `Request` instance from the given `http.ClientRequest`.\n */\nexport function createRequest(clientRequest: NodeClientRequest): Request {\n  const headers = new Headers()\n\n  const outgoingHeaders = clientRequest.getHeaders()\n  for (const headerName in outgoingHeaders) {\n    const headerValue = outgoingHeaders[headerName]\n\n    if (typeof headerValue === 'undefined') {\n      continue\n    }\n\n    const valuesList = Array.prototype.concat([], headerValue)\n    for (const value of valuesList) {\n      headers.append(headerName, value.toString())\n    }\n  }\n\n  /**\n   * Translate the authentication from the request URL to\n   * the request \"Authorization\" header.\n   * @see https://github.com/mswjs/interceptors/issues/438\n   */\n  if (clientRequest.url.username || clientRequest.url.password) {\n    const username = decodeURIComponent(clientRequest.url.username || '')\n    const password = decodeURIComponent(clientRequest.url.password || '')\n    const auth = `${username}:${password}`\n    headers.set('Authorization', `Basic ${btoa(auth)}`)\n\n    // Remove the credentials from the URL since you cannot\n    // construct a Request instance with such a URL.\n    clientRequest.url.username = ''\n    clientRequest.url.password = ''\n  }\n\n  const method = clientRequest.method || 'GET'\n\n  return new Request(clientRequest.url, {\n    method,\n    headers,\n    credentials: 'same-origin',\n    body:\n      method === 'HEAD' || method === 'GET'\n        ? null\n        : clientRequest.requestBuffer,\n  })\n}\n","/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","import { getValueBySymbol } from './getValueBySymbol'\nimport { isObject } from './isObject'\n\ntype RawHeadersMap = Map<string, string>\ntype HeadersMapHeader = { name: string; value: string }\n\n/**\n * Returns raw headers from the given `Headers` instance.\n * @example\n * const headers = new Headers([\n *   ['X-HeadeR-NamE', 'Value']\n * ])\n * getRawFetchHeaders(headers)\n * // { 'X-HeadeR-NamE': 'Value' }\n */\nexport function getRawFetchHeaders(\n  headers: Headers\n): RawHeadersMap | undefined {\n  const headersList = getValueBySymbol<object>('headers list', headers)\n\n  if (!headersList) {\n    return\n  }\n\n  const headersMap = getValueBySymbol<\n    Map<string, string> | Map<string, HeadersMapHeader>\n  >('headers map', headersList)\n\n  /**\n   * @note Older versions of Node.js (e.g. 18.8.0) keep headers map\n   * as Map<normalizedHeaderName, value> without any means to tap\n   * into raw header values. Detect that and return undefined.\n   */\n  if (!headersMap || !isHeadersMapWithRawHeaderNames(headersMap)) {\n    return\n  }\n\n  // Raw headers is a map of { rawHeaderName: rawHeaderValue }\n  const rawHeaders: RawHeadersMap = new Map<string, string>()\n\n  headersMap.forEach(({ name, value }) => {\n    rawHeaders.set(name, value)\n  })\n\n  return rawHeaders\n}\n\nfunction isHeadersMapWithRawHeaderNames(\n  headersMap: Map<string, string> | Map<string, HeadersMapHeader>\n): headersMap is Map<string, HeadersMapHeader> {\n  return Array.from(\n    headersMap.values() as Iterable<string | HeadersMapHeader>\n  ).every((value) => {\n    return isObject<HeadersMapHeader>(value) && 'name' in value\n  })\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n","import {\n  Agent as HttpAgent,\n  globalAgent as httpGlobalAgent,\n  IncomingMessage,\n} from 'http'\nimport {\n  RequestOptions,\n  Agent as HttpsAgent,\n  globalAgent as httpsGlobalAgent,\n} from 'https'\nimport { Url as LegacyURL, parse as parseUrl } from 'url'\nimport { Logger } from '@open-draft/logger'\nimport { getRequestOptionsByUrl } from '../../../utils/getRequestOptionsByUrl'\nimport {\n  ResolvedRequestOptions,\n  getUrlByRequestOptions,\n} from '../../../utils/getUrlByRequestOptions'\nimport { cloneObject } from '../../../utils/cloneObject'\nimport { isObject } from '../../../utils/isObject'\n\nconst logger = new Logger('http normalizeClientRequestArgs')\n\nexport type HttpRequestCallback = (response: IncomingMessage) => void\n\nexport type ClientRequestArgs =\n  // Request without any arguments is also possible.\n  | []\n  | [string | URL | LegacyURL, HttpRequestCallback?]\n  | [string | URL | LegacyURL, RequestOptions, HttpRequestCallback?]\n  | [RequestOptions, HttpRequestCallback?]\n\nfunction resolveRequestOptions(\n  args: ClientRequestArgs,\n  url: URL\n): RequestOptions {\n  // Calling `fetch` provides only URL to `ClientRequest`\n  // without any `RequestOptions` or callback.\n  if (typeof args[1] === 'undefined' || typeof args[1] === 'function') {\n    logger.info('request options not provided, deriving from the url', url)\n    return getRequestOptionsByUrl(url)\n  }\n\n  if (args[1]) {\n    logger.info('has custom RequestOptions!', args[1])\n    const requestOptionsFromUrl = getRequestOptionsByUrl(url)\n\n    logger.info('derived RequestOptions from the URL:', requestOptionsFromUrl)\n\n    /**\n     * Clone the request options to lock their state\n     * at the moment they are provided to `ClientRequest`.\n     * @see https://github.com/mswjs/interceptors/issues/86\n     */\n    logger.info('cloning RequestOptions...')\n    const clonedRequestOptions = cloneObject(args[1])\n    logger.info('successfully cloned RequestOptions!', clonedRequestOptions)\n\n    return {\n      ...requestOptionsFromUrl,\n      ...clonedRequestOptions,\n    }\n  }\n\n  logger.info('using an empty object as request options')\n  return {} as RequestOptions\n}\n\n/**\n * Overrides the given `URL` instance with the explicit properties provided\n * on the `RequestOptions` object. The options object takes precedence,\n * and will replace URL properties like \"host\", \"path\", and \"port\", if specified.\n */\nfunction overrideUrlByRequestOptions(url: URL, options: RequestOptions): URL {\n  url.host = options.host || url.host\n  url.hostname = options.hostname || url.hostname\n  url.port = options.port ? options.port.toString() : url.port\n\n  if (options.path) {\n    const parsedOptionsPath = parseUrl(options.path, false)\n    url.pathname = parsedOptionsPath.pathname || ''\n    url.search = parsedOptionsPath.search || ''\n  }\n\n  return url\n}\n\nfunction resolveCallback(\n  args: ClientRequestArgs\n): HttpRequestCallback | undefined {\n  return typeof args[1] === 'function' ? args[1] : args[2]\n}\n\nexport type NormalizedClientRequestArgs = [\n  url: URL,\n  options: ResolvedRequestOptions,\n  callback?: HttpRequestCallback\n]\n\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\nexport function normalizeClientRequestArgs(\n  defaultProtocol: string,\n  ...args: ClientRequestArgs\n): NormalizedClientRequestArgs {\n  let url: URL\n  let options: ResolvedRequestOptions\n  let callback: HttpRequestCallback | undefined\n\n  logger.info('arguments', args)\n  logger.info('using default protocol:', defaultProtocol)\n\n  // Support \"http.request()\" calls without any arguments.\n  // That call results in a \"GET http://localhost\" request.\n  if (args.length === 0) {\n    const url = new URL('http://localhost')\n    const options = resolveRequestOptions(args, url)\n    return [url, options]\n  }\n\n  // Convert a url string into a URL instance\n  // and derive request options from it.\n  if (typeof args[0] === 'string') {\n    logger.info('first argument is a location string:', args[0])\n\n    url = new URL(args[0])\n    logger.info('created a url:', url)\n\n    const requestOptionsFromUrl = getRequestOptionsByUrl(url)\n    logger.info('request options from url:', requestOptionsFromUrl)\n\n    options = resolveRequestOptions(args, url)\n    logger.info('resolved request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a given URL instance as-is\n  // and derive request options from it.\n  else if (args[0] instanceof URL) {\n    url = args[0]\n    logger.info('first argument is a URL:', url)\n\n    // Check if the second provided argument is RequestOptions.\n    // If it is, check if \"options.path\" was set and rewrite it\n    // on the input URL.\n    // Do this before resolving options from the URL below\n    // to prevent query string from being duplicated in the path.\n    if (typeof args[1] !== 'undefined' && isObject<RequestOptions>(args[1])) {\n      url = overrideUrlByRequestOptions(url, args[1])\n    }\n\n    options = resolveRequestOptions(args, url)\n    logger.info('derived request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n  // or a WHATWG URL.\n  else if ('hash' in args[0] && !('method' in args[0])) {\n    const [legacyUrl] = args\n    logger.info('first argument is a legacy URL:', legacyUrl)\n\n    if (legacyUrl.hostname === null) {\n      /**\n       * We are dealing with a relative url, so use the path as an \"option\" and\n       * merge in any existing options, giving priority to exising options -- i.e. a path in any\n       * existing options will take precedence over the one contained in the url. This is consistent\n       * with the behaviour in ClientRequest.\n       * @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n       */\n      logger.info('given legacy URL is relative (no hostname)')\n\n      return isObject(args[1])\n        ? normalizeClientRequestArgs(\n            defaultProtocol,\n            { path: legacyUrl.path, ...args[1] },\n            args[2]\n          )\n        : normalizeClientRequestArgs(\n            defaultProtocol,\n            { path: legacyUrl.path },\n            args[1] as HttpRequestCallback\n          )\n    }\n\n    logger.info('given legacy url is absolute')\n\n    // We are dealing with an absolute URL, so convert to WHATWG and try again.\n    const resolvedUrl = new URL(legacyUrl.href)\n\n    return args[1] === undefined\n      ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl)\n      : typeof args[1] === 'function'\n      ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl, args[1])\n      : normalizeClientRequestArgs(\n          defaultProtocol,\n          resolvedUrl,\n          args[1],\n          args[2]\n        )\n  }\n  // Handle a given \"RequestOptions\" object as-is\n  // and derive the URL instance from it.\n  else if (isObject(args[0])) {\n    options = args[0] as any\n    logger.info('first argument is RequestOptions:', options)\n\n    // When handling a \"RequestOptions\" object without an explicit \"protocol\",\n    // infer the protocol from the request issuing module (http/https).\n    options.protocol = options.protocol || defaultProtocol\n    logger.info('normalized request options:', options)\n\n    url = getUrlByRequestOptions(options)\n    logger.info('created a URL from RequestOptions:', url.href)\n\n    callback = resolveCallback(args)\n  } else {\n    throw new Error(\n      `Failed to construct ClientRequest with these parameters: ${args}`\n    )\n  }\n\n  options.protocol = options.protocol || url.protocol\n  options.method = options.method || 'GET'\n\n  /**\n   * Infer a fallback agent from the URL protocol.\n   * The interception is done on the \"ClientRequest\" level (\"NodeClientRequest\")\n   * and it may miss the correct agent. Always align the agent\n   * with the URL protocol, if not provided.\n   *\n   * @note Respect the \"agent: false\" value.\n   */\n  if (typeof options.agent === 'undefined') {\n    const agent =\n      options.protocol === 'https:'\n        ? new HttpsAgent({\n            rejectUnauthorized: options.rejectUnauthorized,\n          })\n        : new HttpAgent()\n\n    options.agent = agent\n    logger.info('resolved fallback agent:', agent)\n  }\n\n  /**\n   * Ensure that the default Agent is always set.\n   * This prevents the protocol mismatch for requests with { agent: false },\n   * where the global Agent is inferred.\n   * @see https://github.com/mswjs/msw/issues/1150\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L130\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L157-L159\n   */\n  if (!options._defaultAgent) {\n    logger.info(\n      'has no default agent, setting the default agent for \"%s\"',\n      options.protocol\n    )\n\n    options._defaultAgent =\n      options.protocol === 'https:' ? httpsGlobalAgent : httpGlobalAgent\n  }\n\n  logger.info('successfully resolved url:', url.href)\n  logger.info('successfully resolved options:', options)\n  logger.info('successfully resolved callback:', callback)\n\n  return [url, options, callback]\n}\n","import { RequestOptions } from 'http'\n\n/**\n * Converts a URL instance into the RequestOptions object expected by\n * the `ClientRequest` class.\n * @see https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/internal/url.js#L1257\n */\nexport function getRequestOptionsByUrl(url: URL): RequestOptions {\n  const options: RequestOptions = {\n    method: 'GET',\n    protocol: url.protocol,\n    hostname:\n      typeof url.hostname === 'string' && url.hostname.startsWith('[')\n        ? url.hostname.slice(1, -1)\n        : url.hostname,\n    host: url.host,\n    path: `${url.pathname}${url.search || ''}`,\n  }\n\n  if (!!url.port) {\n    options.port = Number(url.port)\n  }\n\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`\n  }\n\n  return options\n}\n","import { Agent } from 'http'\nimport { RequestOptions, Agent as HttpsAgent } from 'https'\nimport { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('utils getUrlByRequestOptions')\n\n// Request instance constructed by the \"request\" library\n// has a \"self\" property that has a \"uri\" field. This is\n// reproducible by performing a \"XMLHttpRequest\" request in JSDOM.\nexport interface RequestSelf {\n  uri?: URL\n}\n\nexport type ResolvedRequestOptions = RequestOptions & RequestSelf\n\nexport const DEFAULT_PATH = '/'\nconst DEFAULT_PROTOCOL = 'http:'\nconst DEFAULT_HOSTNAME = 'localhost'\nconst SSL_PORT = 443\n\nfunction getAgent(\n  options: ResolvedRequestOptions\n): Agent | HttpsAgent | undefined {\n  return options.agent instanceof Agent ? options.agent : undefined\n}\n\nfunction getProtocolByRequestOptions(options: ResolvedRequestOptions): string {\n  if (options.protocol) {\n    return options.protocol\n  }\n\n  const agent = getAgent(options)\n  const agentProtocol = (agent as RequestOptions)?.protocol\n\n  if (agentProtocol) {\n    return agentProtocol\n  }\n\n  const port = getPortByRequestOptions(options)\n  const isSecureRequest = options.cert || port === SSL_PORT\n\n  return isSecureRequest ? 'https:' : options.uri?.protocol || DEFAULT_PROTOCOL\n}\n\nfunction getPortByRequestOptions(\n  options: ResolvedRequestOptions\n): number | undefined {\n  // Use the explicitly provided port.\n  if (options.port) {\n    return Number(options.port)\n  }\n\n  // Otherwise, try to resolve port from the agent.\n  const agent = getAgent(options)\n\n  if ((agent as HttpsAgent)?.options.port) {\n    return Number((agent as HttpsAgent).options.port)\n  }\n\n  if ((agent as RequestOptions)?.defaultPort) {\n    return Number((agent as RequestOptions).defaultPort)\n  }\n\n  // Lastly, return undefined indicating that the port\n  // must inferred from the protocol. Do not infer it here.\n  return undefined\n}\n\ninterface RequestAuth {\n  username: string\n  password: string\n}\n\nfunction getAuthByRequestOptions(\n  options: ResolvedRequestOptions\n): RequestAuth | undefined {\n  if (options.auth) {\n    const [username, password] = options.auth.split(':')\n    return { username, password }\n  }\n}\n\n/**\n * Returns true if host looks like an IPv6 address without surrounding brackets\n * It assumes any host containing `:` is definitely not IPv4 and probably IPv6,\n * but note that this could include invalid IPv6 addresses as well.\n */\nfunction isRawIPv6Address(host: string): boolean {\n  return host.includes(':') && !host.startsWith('[') && !host.endsWith(']')\n}\n\nfunction getHostname(options: ResolvedRequestOptions): string | undefined {\n  let host = options.hostname || options.host\n\n  if (host) {\n    if (isRawIPv6Address(host)) {\n       host = `[${host}]`\n    }\n\n    // Check the presence of the port, and if it's present,\n    // remove it from the host, returning a hostname.\n    return new URL(`http://${host}`).hostname\n  }\n\n  return DEFAULT_HOSTNAME\n}\n\n/**\n * Creates a `URL` instance from a given `RequestOptions` object.\n */\nexport function getUrlByRequestOptions(options: ResolvedRequestOptions): URL {\n  logger.info('request options', options)\n\n  if (options.uri) {\n    logger.info(\n      'constructing url from explicitly provided \"options.uri\": %s',\n      options.uri\n    )\n    return new URL(options.uri.href)\n  }\n\n  logger.info('figuring out url from request options...')\n\n  const protocol = getProtocolByRequestOptions(options)\n  logger.info('protocol', protocol)\n\n  const port = getPortByRequestOptions(options)\n  logger.info('port', port)\n\n  const hostname = getHostname(options)\n  logger.info('hostname', hostname)\n\n  const path = options.path || DEFAULT_PATH\n  logger.info('path', path)\n\n  const credentials = getAuthByRequestOptions(options)\n  logger.info('credentials', credentials)\n\n  const authString = credentials\n    ? `${credentials.username}:${credentials.password}@`\n    : ''\n  logger.info('auth string:', authString)\n\n  const portString = typeof port !== 'undefined' ? `:${port}` : ''\n  const url = new URL(`${protocol}//${hostname}${portString}${path}`)\n  url.username = credentials?.username || ''\n  url.password = credentials?.password || ''\n\n  logger.info('created url:', url)\n\n  return url\n}\n","import { Logger } from '@open-draft/logger'\n\nconst logger = new Logger('cloneObject')\n\nfunction isPlainObject(obj?: Record<string, any>): boolean {\n  logger.info('is plain object?', obj)\n\n  if (obj == null || !obj.constructor?.name) {\n    logger.info('given object is undefined, not a plain object...')\n    return false\n  }\n\n  logger.info('checking the object constructor:', obj.constructor.name)\n  return obj.constructor.name === 'Object'\n}\n\nexport function cloneObject<ObjectType extends Record<string, any>>(\n  obj: ObjectType\n): ObjectType {\n  logger.info('cloning object:', obj)\n\n  const enumerableProperties = Object.entries(obj).reduce<Record<string, any>>(\n    (acc, [key, value]) => {\n      logger.info('analyzing key-value pair:', key, value)\n\n      // Recursively clone only plain objects, omitting class instances.\n      acc[key] = isPlainObject(value) ? cloneObject(value) : value\n      return acc\n    },\n    {}\n  )\n\n  return isPlainObject(obj)\n    ? enumerableProperties\n    : Object.assign(Object.getPrototypeOf(obj), enumerableProperties)\n}\n","import { ClientRequest } from 'node:http'\nimport {\n  NodeClientOptions,\n  NodeClientRequest,\n  Protocol,\n} from './NodeClientRequest'\nimport {\n  ClientRequestArgs,\n  normalizeClientRequestArgs,\n} from './utils/normalizeClientRequestArgs'\n\nexport function get(protocol: Protocol, options: NodeClientOptions) {\n  return function interceptorsHttpGet(\n    ...args: ClientRequestArgs\n  ): ClientRequest {\n    const clientRequestArgs = normalizeClientRequestArgs(\n      `${protocol}:`,\n      ...args\n    )\n    const request = new NodeClientRequest(clientRequestArgs, options)\n\n    /**\n     * @note https://nodejs.org/api/http.html#httpgetoptions-callback\n     * \"http.get\" sets the method to \"GET\" and calls \"req.end()\" automatically.\n     */\n    request.end()\n\n    return request\n  }\n}\n","import { ClientRequest } from 'http'\nimport { Logger } from '@open-draft/logger'\nimport {\n  NodeClientOptions,\n  NodeClientRequest,\n  Protocol,\n} from './NodeClientRequest'\nimport {\n  normalizeClientRequestArgs,\n  ClientRequestArgs,\n} from './utils/normalizeClientRequestArgs'\n\nconst logger = new Logger('http request')\n\nexport function request(protocol: Protocol, options: NodeClientOptions) {\n  return function interceptorsHttpRequest(\n    ...args: ClientRequestArgs\n  ): ClientRequest {\n    logger.info('request call (protocol \"%s\"):', protocol, args)\n\n    const clientRequestArgs = normalizeClientRequestArgs(\n      `${protocol}:`,\n      ...args\n    )\n    return new NodeClientRequest(clientRequestArgs, options)\n  }\n}\n"]}